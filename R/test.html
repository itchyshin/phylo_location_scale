<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>test</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="test_files/libs/clipboard/clipboard.min.js"></script>
<script src="test_files/libs/quarto-html/quarto.js"></script>
<script src="test_files/libs/quarto-html/popper.min.js"></script>
<script src="test_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="test_files/libs/quarto-html/anchor.min.js"></script>
<link href="test_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="test_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="test_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="test_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="test_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">test</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="phylogenetic-location-scale-model" class="level1">
<h1>Phylogenetic Location-Scale Model</h1>
<section id="without-a-random-effect-in-the-scale-part" class="level2">
<h2 class="anchored" data-anchor-id="without-a-random-effect-in-the-scale-part">Without a Random Effect in the Scale Part</h2>
<p>You start by defining a location model for a trait <span class="math inline">\(y_i\)</span> (e.g., body mass) across species i :</p>
<ol type="1">
<li>Location Model:</li>
</ol>
<p><span class="math display">\[
y_i = \beta0^{(l)} + \sum_{k=1}^K \beta_k^{(l)} x_{ki} + a_i^{(l)} + e_i^{(l)}
\]</span></p>
<p>• <span class="math inline">\(y_i\)</span> : Observed trait value for species i . • <span class="math inline">\(\beta_0^{(l)}\)</span> : Intercept for the location model. • <span class="math inline">\(\beta_k^{(l)}\)</span> : Fixed-effect coefficients for predictor variables <span class="math inline">\(x_{ki}\)</span> (e.g., species range). • <span class="math inline">\(a_i^{(l)}\)</span> : Phylogenetic random effect, accounting for shared evolutionary history. • <span class="math inline">\(e_i^{(l)}\)</span> : Residual error for the location model.</p>
<ol start="2" type="1">
<li>Scale Model:</li>
</ol>
<p>The variance of the residuals is modeled as a function of predictors:</p>
<p><span class="math display">\[
\ln(\sigma_{e_i}) = \beta_0^{(s)} + \sum_{k=1}^K \beta_k^{(s)} x_{ki}
\]</span></p>
<p>• <span class="math inline">\(\sigma_{e_i}\)</span> : Standard deviation of the residual error for species i . • <span class="math inline">\(\beta_0^{(s)}\)</span> : Intercept for the scale model. • <span class="math inline">\(\beta_k^{(s)}\)</span> : Fixed-effect coefficients for predictors in the scale model.</p>
<ol start="3" type="1">
<li>Random Effects: • Phylogenetic Random Effect in Location Model:</li>
</ol>
<p><span class="math display">\[a_i^{(l)} \sim \mathcal{N}\left(0, \sigma\_{a(l)}^2 \mathbf{A}\right)\]</span></p>
<p>• <span class="math inline">\(\sigma_{a(l)}^2\)</span> : Variance of the phylogenetic random effect. • <span class="math inline">\(\mathbf{A}\)</span> : Phylogenetic relatedness matrix. • Residuals:</p>
<p><span class="math display">\[e_i^{(l)} \sim \mathcal{N}\left(0, \sigma\_{e_i(l)}^2 \mathbf{I}\right)\]</span></p>
<p>• <span class="math inline">\(\sigma_{e_i(l)}^2\)</span> : Species-specific residual variance from the scale model. • <span class="math inline">\(\mathbf{I}\)</span> : Identity matrix, assuming independence. 4. Phylogenetic Signal:</p>
<p>The phylogenetic heritability ( H^2 ) quantifies the proportion of total variance attributable to phylogenetic effects:</p>
<p><span class="math display">\[H^2 = H^2_{(l)} = \frac{\sigma_{a(l)}^2}{\sigma_{a(l)}^2 + \bar{\sigma}_{e_i(l)}^2}\]</span></p>
<p>• <span class="math inline">\(\bar{\sigma}_{e_i(l)}^2\)</span> : Average residual variance across species, derived from the scale model.</p>
<p>Alternatively, accounting for variance explained by fixed effects:</p>
<p><span class="math display">\[H^2 = \frac{\sigma_{a(l)}^2}{\sigma_p^2}\]</span></p>
<p>where total phenotypic variance <span class="math inline">\(\sigma_p^2\)</span> is:</p>
<p><span class="math display">\[\sigma_p^2 =* \sigma{a(l)}^2 + \sigma_{f(l)}^2 + \bar{\sigma}_{e_i(l)}^2\]</span></p>
<p>• <span class="math inline">\(\sigma\_{f(l)}\^2\)</span> : Variance due to fixed effects in the location model. 5. Evolvability:</p>
<p>Evolvability measures the potential for evolutionary change:</p>
<p><span class="math display">\[\text{CV}A = \frac{\sigma{a(l)}}{E(y_i)}\]</span></p>
<p>• <span class="math inline">\(\text{CV}_A\)</span> : Coefficient of variation due to phylogenetic effects. • <span class="math inline">\(E(y_i)\)</span> : Expected mean trait value. 6. Calculating Average Residual Variance:</p>
<p>The average residual variance is:</p>
<p><span class="math display">\[
\bar{\sigma}{e_i}^2 = \exp\left(2 \beta_0^{(s)} + 2 \sigma_{a(s)}^2\right)
\]</span></p>
<p>• <span class="math inline">\(\sigma_{as(\ln)}^2\)</span> : Variance of the scale model (if applicable).</p>
</section>
<section id="with-a-random-effect-in-the-scale-part" class="level2">
<h2 class="anchored" data-anchor-id="with-a-random-effect-in-the-scale-part">With a Random Effect in the Scale Part</h2>
<p>With a Random Effect in the Scale Part</p>
<p>Here, you introduce a phylogenetic random effect in the scale model: 1. Location Model: Same as before:</p>
<p><span class="math display">\[
y_i = \beta_0^{(l)} + \sum_{k=1}x^K \beta*k^{(l)} x*{ki} + a_i^{(l)} + e_i^{(l)}
\]</span></p>
<ol start="2" type="1">
<li>Scale Model with Random Effect:</li>
</ol>
<p><span class="math display">\[
\ln(\sigma_{e_i(l)}) = \beta_0^{(s)} + \sum_{k=1}^K \beta_k^{(s)} x_{ki} + a_i^{(s)}
\]</span></p>
<p>• <span class="math inline">\(a_i^{(s)}\)</span> : Phylogenetic random effect in the scale model. 3. Residuals:</p>
<p><span class="math display">\[
e_i^{(l)} \sim \mathcal{N}\left(0, \sigma_{e_i(l)}^2 \mathbf{I}\right)
\]</span></p>
<ol start="4" type="1">
<li>Joint Distribution of Random Effects:</li>
</ol>
<p><span class="math display">\[
\begin{pmatrix}
a_i^{(l)} \\
a_i^{(s)}
\end{pmatrix}
\sim \mathcal{N} \left(
\begin{pmatrix}
0 \\
0
\end{pmatrix}
, \boldsymbol{\Sigma}\_a \otimes \mathbf{A} \right)
\]</span></p>
<p>with the covariance matrix:</p>
<p><span class="math display">\[
\boldsymbol{\Sigma}a \otimes \mathbf{A} =
\begin{pmatrix}
\sigma{a(l)}^2 \mathbf{A} &amp; \rho_{ls} \sigma_{a(l)} \sigma_{a(s(\ln))} \mathbf{A} \\
\rho_{ls} \sigma_{a(l)} \sigma_{a(s(\ln))} \mathbf{A} &amp; \sigma_{a(s(\ln))}^2 \mathbf{A}
\end{pmatrix}
\]</span></p>
<p>• <span class="math inline">\(\rho_{ls}\)</span> : Correlation between the location and scale phylogenetic effects. 5. Adjusted Phylogenetic Signal:</p>
<p><span class="math display">\[
H^2_{(l)} = \frac{\sigma_{a(l)}^2}{\sigma_{a(l)}^2 + \bar{\sigma}_{e_i(l)}^2}
\]</span></p>
<p>where:</p>
<p><span class="math display">\[
\bar{\sigma}_{e_i(l)}^2 = \exp\left(2 \beta_0^{(s)} + 2 \sigma_{a(s)}^2\right)
\]</span></p>
<ol start="6" type="1">
<li>Variance Components in Scale Model:</li>
</ol>
<p>The variance of <span class="math inline">\(\sigma_{e_i(l)}^2\)</span> :</p>
<p><span class="math display">\[
\sigma_{\sigma_{e(l)}^2}^2 = \left( \exp\left(4 \sigma*{a(s)}^2\right) - 1 \right) \exp\left(4 \left( \beta_0^{(s)} + \sigma_{a(s)}^2 + \sigma{f(s)}^2 \right) \right)
\]</span></p>
<p>• <span class="math inline">\(\sigma_{f(s)}^2\)</span> : Variance due to fixed effects in the scale model. 7. Evolvability in Scale:</p>
<p><span class="math inline">\(\text{CV}_A^{(s)} = \frac{\sigma{a(s)}}{E(\sigma_{e_i(l)}^2)}\)</span></p>
<p>Alternatively, if variance in fixed effects is not accounted for:</p>
<p><span class="math inline">\(\text{CV}_A^{(s)} = \sqrt{\exp\left(\sigma{a(s)}^2\right) - 1}\)</span></p>
</section>
<section id="extension-to-multivariate-models" class="level2">
<h2 class="anchored" data-anchor-id="extension-to-multivariate-models">Extension to Multivariate Models</h2>
<p>You further extend the model to a multivariate framework, allowing for multiple traits and their variances to be modeled simultaneously.</p>
<p>Joint Location Models:</p>
<p><span class="math display">\[
\mathbf{y}_{i} =
\begin{pmatrix}
y_i^{(1)} \\
y_i^{(2)}
\end{pmatrix}
\begin{pmatrix}
\beta_0^{(l1)} + \sum_{k=1}^K \beta_k^{(l1)} x_{ki} + a_i^{(l1)} + e_i^{(l1)} \\
\beta_0^{(l2)} + \sum_{k=1}^K \beta_k^{(l2)} x_{ki} + a_i^{(l2)} + e_i^{(l2)}
\end{pmatrix}
\]</span></p>
<p>Joint Scale Models:</p>
<p><span class="math display">\[
\ln\left( \boldsymbol{\sigma}{e_i} \right) =
\begin{pmatrix}
\ln(\sigma_{e_i(l1)}) \\
\ln(\sigma_{e_i(l2)})
\end{pmatrix}
\begin{pmatrix}
\beta_0^{(s1)} + \sum_{k=1}^K \beta_k^{(s1)} x_{ki} + a_i^{(s1)} \\
\beta_0^{(s2)} + \sum_{k=1}^K \beta_k^{(s2)} x_{ki} + a_i^{(s2)}
\end{pmatrix}
\]</span></p>
<p>Joint Random Effects:</p>
<p><span class="math display">\[
\begin{pmatrix}
a_i^{(l1)} \\
a_i^{(l2)} \\
a_i^{(s1)} \\
a_i^{(s2)}
\end{pmatrix}
\sim \mathcal{N} \left(
\begin{pmatrix}
0 \\
0 \\
0 \\
0
\end{pmatrix}
, \boldsymbol{\Sigma}\_a \otimes \mathbf{A} \right)
\]</span></p>
<p>The covariance matrix <span class="math inline">\(\boldsymbol{\Sigma}\)</span> <em>a captures: •</em> <span class="math inline">\(\rho_{a(l1l2)}\)</span> : Mean-mean coevolution between traits. • <span class="math inline">\(\rho)_{a(s1s2)}\)</span> : Variance-variance coevolution between traits. •<span class="math inline">\(\\rho_{a(l1s1)}\)</span>, <span class="math inline">\(\rho_{a(l2s2)}\)</span> : Mean-variance coevolution within traits. •<span class="math inline">\(\rho_{a(l1s2)}\)</span>, <span class="math inline">\(\rho_{a(l2s1)}\)</span> : Mean-variance coevolution across traits.</p>
</section>
<section id="multivariate-phylogenetic-location-scale-model" class="level2">
<h2 class="anchored" data-anchor-id="multivariate-phylogenetic-location-scale-model">Multivariate Phylogenetic Location-Scale Model</h2>
<p>In matrix notation, the model becomes: 1. Location Model:</p>
<p><span class="math display">\[
\mathbf{y}_i = \mathbf{X}_i \boldsymbol{\beta}^{(l)} + \mathbf{a}_i^{(l)} + \mathbf{e}_i^{(l)}
\]</span></p>
<ol start="2" type="1">
<li>Scale Model:</li>
</ol>
<p><span class="math display">\[
\ln\left( \boldsymbol{\sigma}_{\mathbf{e}_i(l)} \right) = \mathbf{X}_i \boldsymbol{\beta}^{(s)} + \mathbf{a}_i^{(s)}
\]</span></p>
</section>
<section id="phylogenetic-location-scale-model-with-within-species-effects" class="level2">
<h2 class="anchored" data-anchor-id="phylogenetic-location-scale-model-with-within-species-effects">Phylogenetic Location-Scale Model with Within-Species Effects</h2>
<p>This extension accounts for individual-level variability within species: 1. Location Model:</p>
<p><span class="math display">\[
y_{ij} = \beta_0^{(l)} + \sum_{k=1}^K \beta_k^{(l)} x_{kij} + a_i^{(l)} + e_i^{(l)} + \varepsilon_{ij}^{(l)}
\]</span></p>
<p>• <span class="math inline">\(y_{ij}\)</span> : Observation j within species i . • <span class="math inline">\(x_{kij}\)</span> : Predictor variables at the individual level. • <span class="math inline">\(\varepsilon_{ij}^{(l)}\)</span> : Individual-level residual error. 2. Scale Model:</p>
<p><span class="math display">\[
\ln(\sigma_{\varepsilon_{ij}(l)}) = \beta_0^{(s)} + \sum_{k=1}^K \beta_k^{(s)} x_{kij} + a_i^{(s)} + e_i^{(s)}
\]</span> • <span class="math inline">\(\sigma_{\varepsilon_{ij}(l)}\)</span> : Individual-level residual standard deviation. 3. Random Effects: • Phylogenetic Random Effects:</p>
<p><span class="math display">\[
\begin{pmatrix}
a_i^{(l)} \\
a_i^{(s)}
\end{pmatrix}
\sim \mathcal{N}\left(0, \boldsymbol{\Sigma}_{a(ls)} \otimes \mathbf{A}\right)
\]</span> • Species-Level Residuals:</p>
<p><span class="math display">\[
\begin{pmatrix}
e_i^{(l)} \\
e_i^{(s)}
\end{pmatrix}
\sim \mathcal{N}\left(0, \boldsymbol{\Sigma}_e \otimes \mathbf{I}\right)
\]</span> • Individual-Level Residuals: <span class="math display">\[
\varepsilon_{ij}^{(l)} \sim \mathcal{N}\left(0, \sigma_{\varepsilon_{ij}(l)}^2\right)
\]</span></p>
</section>
<section id="thoughts-and-suggestions" class="level2">
<h2 class="anchored" data-anchor-id="thoughts-and-suggestions">Thoughts and Suggestions</h2>
<ol type="1">
<li>Novel Contribution: Extending location-scale models to phylogenetic comparative analysis is a significant advancement. It allows for the examination of how both the mean and variability of traits are influenced by evolutionary relationships.</li>
<li>Interpretation of Random Effects: • Phylogenetic Random Effects in Scale Model: Incorporating <span class="math inline">\(a_i^{(s)}\)</span> acknowledges that the variability of a trait can also be phylogenetically structured. • Correlation Between Location and Scale Effects: The parameter <span class="math inline">\(\rho_{ls}\)</span> can provide insights into whether species that have higher mean trait values also tend to have greater variability.</li>
<li>Complexity and Identifiability: • Model Complexity: With the addition of random effects in both the location and scale parts, and their potential correlations, the model becomes complex. • Data Requirements: Adequate sample sizes at both the species and individual levels (if applicable) are necessary to reliably estimate parameters.</li>
<li>Statistical Estimation: • Bayesian Methods: Given the complexity, Bayesian approaches (e.g., using MCMC techniques) might be more suitable for parameter estimation. • Software: Software like Stan or MCMCglmm in R can handle such models but may require careful coding and convergence diagnostics.</li>
<li>Assumptions: • Normality: The models assume normal distributions for random effects and residuals, which should be assessed in practice. • Log-Linear Relationship: The log-linear form of the scale model assumes multiplicative effects on variance, which is reasonable but should be validated.</li>
<li>Applications: • Trait Variability: Useful for studying traits where variability is biologically meaningful, such as behavioral traits, phenotypic plasticity, or developmental instability. • Evolutionary Questions: Can address whether evolutionary processes affect not just trait means but also the dispersion around those means.</li>
<li>Interpretation of Evolvability: • Evolvability in Mean and Variance: By calculating coefficients of variation for both location and scale components, you can compare the potential for evolutionary change in both aspects.</li>
</ol>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Your proposed models offer a comprehensive framework for phylogenetic comparative analysis that accounts for both the mean and variance of traits across species. This extension has the potential to reveal new insights into evolutionary processes affecting trait evolution.</p>
<p>Next Steps: • Empirical Validation: Apply the models to real datasets to test their applicability and refine them based on practical findings. • Simulation Studies: Conduct simulations to assess the performance of the models under different conditions (e.g., varying sample sizes, effect sizes). • Further Development: Explore the possibility of including other types of random effects or extending the models to non-Gaussian traits. • Collaboration: Consider collaborating with statisticians or computational biologists to tackle potential challenges in model estimation and interpretation.</p>
<ol type="1">
<li>Phylogenetic Generalized Least Squares (PGLS):</li>
</ol>
<p>• Description: PGLS is a standard method in comparative biology that incorporates phylogenetic relationships into regression analyses of continuous traits. It models the covariance among species due to shared ancestry using a phylogenetic covariance matrix. • Relation to Your Work: While PGLS typically focuses on the mean structure of traits, extensions of PGLS can account for heteroscedasticity (non-constant variance) across species. This could be analogous to modeling the scale (variance) component in your location-scale model.</p>
<ol start="2" type="1">
<li><p>Phylogenetic Mixed Models (PMM): • Description: Phylogenetic mixed models extend linear mixed models by including random effects that capture the phylogenetic relationships among species. These models can handle complex data structures and multiple random effects. • Relation to Your Work: Your inclusion of phylogenetic random effects in both the mean (location) and variance (scale) components aligns with the framework of PMMs. They provide a foundation for modeling trait evolution while accounting for phylogenetic dependencies.</p></li>
<li><p>Phylogenetic Generalized Linear Mixed Models (PGLMM): • Description: PGLMMs extend generalized linear mixed models to phylogenetic comparative data, allowing for non-normal response variables (e.g., binary, count data) and incorporating phylogenetic random effects. • Relation to Your Work: If you plan to extend your models to handle non-Gaussian traits or generalized responses, PGLMMs provide a relevant framework. They can accommodate overdispersion and hierarchical variance structures, similar to your scale modeling.</p></li>
<li><p>Heteroskedastic Models in Phylogenetics: • Description: Some studies have developed phylogenetic models that allow for heteroskedasticity, where the variance differs among species and may depend on predictor variables. • Example: Ives, Midford, and Garland (2007) introduced methods to incorporate within-species variance and measurement error into phylogenetic comparative analyses. • Relation to Your Work: These models consider variance heterogeneity across species, which is conceptually similar to your scale model where the residual variance is modeled as a function of predictors.</p></li>
<li><p>Bayesian Phylogenetic Models: • Description: Bayesian approaches offer flexibility in modeling complex hierarchical structures and variance components. Software like MCMCglmm allows for specifying models with phylogenetic random effects and can handle multiple variance structures. • Relation to Your Work: Your proposed models, especially with random effects in both location and scale components, could be implemented within a Bayesian framework. This allows for direct estimation of the posterior distributions of all parameters, including variances and covariances.</p></li>
<li><p>Phylogenetic Meta-analysis: • Description: Phylogenetic meta-analysis combines effect sizes from multiple studies while accounting for phylogenetic relationships among species. It often models both the mean effect and the variance among studies or species. • Relation to Your Work: Techniques from phylogenetic meta-analysis could inform your modeling of variance components, especially if you’re dealing with aggregated data or effect sizes that come with their own variances.</p></li>
<li><p>Models of Trait Variance Evolution: • Description: Some researchers have explored models where not only the trait means but also the variances evolve across the phylogeny. • Example: Hansen, Pienaar, and Orzack (2008) discussed models of stabilizing selection that can incorporate changing variances over time. • Relation to Your Work: Your scale model aligns with the idea of modeling the evolution of trait variances. Incorporating changing variances can provide insights into evolutionary processes like stabilizing selection or adaptive radiation.</p></li>
<li><p>Ornstein-Uhlenbeck (OU) Models with Variable Selection Strength: • Description: OU models are used to model trait evolution under stabilizing selection towards an optimal value. Extensions of OU models allow for varying selection strengths and optima across the phylogeny. • Relation to Your Work: While traditional OU models focus on the mean trait evolution, some extensions consider heterogeneity in evolutionary rates, which could be analogous to modeling variance (scale) in your framework.</p></li>
<li><p>Measurement Error and Within-Species Variation Models: • Description: These models explicitly account for measurement error and within-species variation when estimating phylogenetic signal and evolutionary parameters. • Relation to Your Work: By incorporating within-species variance into your scale model, you can improve the accuracy of phylogenetic comparative analyses, especially when within-species variation is substantial.</p></li>
<li><p>Phylogenetic Path Analysis: • Description: Phylogenetic path analysis allows for modeling complex relationships among multiple traits while accounting for phylogenetic relationships. • Relation to Your Work: While not directly modeling variance components, path analysis can be extended to include variance modeling, potentially integrating with your multivariate location-scale models.</p></li>
</ol>
</section>
<section id="references-for-further-reading" class="level2">
<h2 class="anchored" data-anchor-id="references-for-further-reading">References for Further Reading:</h2>
<ol type="1">
<li><p>Ives, A. R., Midford, P. E., &amp; Garland, T. (2007). Within-species variation and measurement error in phylogenetic comparative methods. Systematic Biology, 56(2), 252–270.</p></li>
<li><p>Hadfield, J. D. (2010). MCMC methods for multi-response generalized linear mixed models: The MCMCglmm R package. Journal of Statistical Software, 33(2), 1–22.</p></li>
<li><p>Hansen, T. F., Pienaar, J., &amp; Orzack, S. H. (2008). A comparative method for studying adaptation to a randomly evolving environment. Evolution, 62(8), 1965–1977.</p></li>
<li><p>Beaulieu, J. M., Jhwueng, D. C., Boettiger, C., &amp; O’Meara, B. C. (2012). Modeling stabilizing selection: Expanding the Ornstein-Uhlenbeck model of adaptive evolution. Evolution, 66(8), 2369–2383.</p></li>
<li><p>Pennell, M. W., &amp; Harmon, L. J. (2013). An integrative view of phylogenetic comparative methods: Connections to population genetics, community ecology, and paleobiology. Annals of the New York Academy of Sciences, 1289(1), 90–105.</p></li>
</ol>
<p>While your approach of extending scale and location models to phylogenetic comparative analysis is innovative, these related methods offer foundational concepts and techniques that might be valuable. They can provide insights into modeling variances, covariances, and evolutionary processes affecting both trait means and variances.</p>
<p>Suggestions: • Integrate Concepts: Consider how elements from these methods can be integrated into your models, especially regarding variance modeling and phylogenetic covariance structures. • Software Implementation: Look into software packages like MCMCglmm in R, which can handle complex hierarchical models with phylogenetic relationships and might be suitable for your analysis. • Collaborate and Consult: Engaging with other researchers who have experience in these methods could provide practical insights and help refine your models.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>